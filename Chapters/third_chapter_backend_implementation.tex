\section{ГЛАВА 3 РЕАЛИЗАЦИЯ СЕРВИСНОЙ ЧАСТИ}

\subsection*{3.1 Технологический стек}
\addcontentsline{toc}{subsection}{3.1 Технологический стек}

\subsubsection*{Go 1.24.0 единообразие в микросервисах}
\texttt{Go 1.24.0} выбран в качестве основного языка разработки для всех микросервисов системы. Это решение обеспечивает простоту сопровождения: \texttt{Go} имеет лаконичный и выразительный синтаксис, строгую статическую типизацию и стандартные инструменты форматирования (например, \texttt{gofmt}), что упрощает чтение и поддержку кода. Кроме того, \texttt{Go} предоставляет эффективное управление памятью и масштабируемую модель конкурентности. Легковесные горутины и оптимизированный сборщик мусора позволяют сервисам обрабатывать множество одновременных запросов без существенного роста потребления ресурсов. Единый язык и стек библиотек упрощают обучение новой команды и стандартизацию практик разработки.
\begin{itemize}
    \item Детерминированность сборки: Механизм модулей \texttt{Go} (\texttt{go.mod} и \texttt{go.sum}) строго фиксирует версии всех зависимостей и их контрольные суммы. Это гарантирует, что сборки на локальных машинах, в \texttt{CI/CD} и на продакшн-среде будут идентичными, исключая «эффект снежинки». Благодаря этому на каждом этапе конвейера мы получаем точно известный набор библиотек, что повышает воспроизводимость и стабильность системы.
    \item Контроль качества кода: для поддержки единообразия стиля и обнаружения ошибок применяется статический анализатор \texttt{golangci-lint}. Этот инструмент запускает множество линтеров параллельно (проверка форматирования, выявление забытых проверок ошибок, поиск потенциальных утечек и др.) и интегрируется в процесс \texttt{CI}. Интеграция \texttt{golangci-lint} позволяет на раннем этапе обнаруживать дефекты и поддерживать единый стандарт качества кода.
\end{itemize}

\subsubsection*{\texttt{gRPC} и отказ от \texttt{REST}}
Межсервисное взаимодействие организовано с использованием \texttt{gRPC}, что обеспечивает бинарную сериализацию данных (\texttt{Protocol Buffers}) и строгое определение контрактов. В отличие от \texttt{REST}, \texttt{gRPC} передаёт сообщения в компактном бинарном формате по протоколу \texttt{HTTP/2}, что снижает сетевые задержки и уменьшает объём передаваемых данных. Определение интерфейсов и типов сообщений в файлах \texttt{.proto} задаёт жёсткую схему запросов и ответов, благодаря чему генерируемый \texttt{Go}-код точно соответствует контракту. Это позволяет компилятору выявлять несоответствия на этапе сборки и предотвращает ошибки интерфейса между сервисами.
\begin{itemize}
    \item Бинарная сериализация и эффективность: \texttt{gRPC} использует \texttt{HTTP/2} и \texttt{Protocol Buffers}, что даёт более компактные сообщения и эффективную сериализацию по сравнению с текстовым \texttt{JSON}. Меньший объём данных и мультиплексирование запросов на одном соединении приводят к низкой задержке и высокой пропускной способности, особенно при большом числе мелких вызовов.
    \item Строгие контракты и стабильность \texttt{API}: Определение сервисов в \texttt{.proto}-файлах задаёт чёткие схемы запросов и ответов. Для \texttt{Go} применяются плагины \texttt{protoc-gen-go} и \texttt{protoc-gen-go-grpc}, автоматически генерирующие типобезопасные структуры, сервисные интерфейсы и клиентские/серверные заглушки. При внесении изменений компилятор быстро выявляет возможные несовместимости, что повышает надёжность и контролируемость версий \texttt{API}.
    \item Двунаправленные стримы: \texttt{gRPC} поддерживает как однонаправленные, так и двунаправленные потоки данных. Это позволяет серверам и клиентам обмениваться сообщениями в режиме реального времени и передавать данные по мере их готовности, без необходимости дожидаться завершения каждого запроса. Такой подход полезен для реализации непрерывных событийных подписок и долгоживущих потоковых операций.
    \item Отказ от \texttt{REST}: \texttt{gRPC} выбран вместо \texttt{REST} ввиду строгого подхода к описанию интерфейсов и высокой производительности. \texttt{REST} с \texttt{JSON}-представлением создаёт дополнительные расходы на сериализацию и десериализацию и требует ручной валидации данных, что увеличивает задержки при большом числе запросов. В тесно интегрированной микросервисной среде эти накладные расходы могут стать узким местом, тогда как строго типизированный и генерируемый \texttt{gRPC} обеспечивает масштабируемость и упрощает сопровождение системы.
\end{itemize}

\subsubsection*{Логирование и конфигурация}
Интерфейс логгера основан на библиотеке \texttt{zap} (Uber) и обёрнут в собственный модуль. Такой подход обеспечивает высокую производительность и структурированный вывод логов (каждое сообщение содержит уровень, метку времени и дополнительные поля). Ротация логов организована с помощью пакета \texttt{lumberjack}: при достижении заданного размера или срока хранения текущий файл переименовывается и создаётся новый, что предотвращает бесконтрольный рост логов. Логи записываются одновременно в стандартный поток \texttt{stdout} (важно для контейнеризированной среды) и в файлы, что упрощает как оперативный мониторинг (например, сбор логов через оркестратор), так и долговременное хранение журналов.
\begin{itemize}
    \item Обёртка над \texttt{zap}: высокопроизводительное и структурированное логирование с возможностью добавления метаданных (уровень, модуль, временная метка и т. д.).
    \item \texttt{Lumberjack}: пакет для ротации лог-файлов по размеру и времени (архивирование устаревших файлов).
    \item Одновременный вывод: запись логов как в \texttt{stdout} (для сбора логов контейнеризатором), так и в файл (для архивации и анализа).
\end{itemize}
Конфигурация сервисов хранится в \texttt{YAML}-файлах и загружается с помощью \texttt{gopkg.in/yaml.v3}. Формат \texttt{YAML} выбран из-за его читабельности и поддержки вложенных структур и комментариев. Библиотека \texttt{yaml.v3} десериализует данные конфигурации (например, параметры баз данных, порты, флаги) прямо в структуры \texttt{Go} (через теги \texttt{yaml}), что обеспечивает строгую типизацию и валидацию. Благодаря единому \texttt{YAML}-файлу все параметры сосредоточены в одном месте, легко читаются и изменяются без сложной сериализации или форматирования.
\begin{itemize}
    \item Формат \texttt{YAML}: человекочитаемый, поддерживает вложенность и комментарии, упрощает ручную правку конфигов.
    \item \texttt{gopkg.in/yaml.v3}: преобразует \texttt{YAML} в \texttt{Go}-структуры по тегам \texttt{yaml}, обеспечивая строгую проверку и удобный доступ к параметрам.
\end{itemize}

\subsubsection*{\texttt{PostgreSQL} и \texttt{Redis}}
Для работы с \texttt{PostgreSQL} используется стандартный пакет \texttt{database/sql} вместе с драйвером (\texttt{pgx} или \texttt{pq}). Такой подход даёт полный контроль над \texttt{SQL}-запросами и высокую прозрачность операций: все \texttt{SQL}-команды пишутся вручную, что позволяет точно понимать, какие запросы выполняются, и оптимизировать их при необходимости. Отсутствие \texttt{ORM} снижает «магический» код и упрощает отладку. Транзакции и подготовленные выражения (\texttt{PreparedStatement}) позволяют эффективно управлять соединениями и защищать от \texttt{SQL-инъекций}.
\begin{itemize}
    \item Контроль и прозрачность: \texttt{database/sql} предоставляет гибкость и прямой контроль над запросами (сложные \texttt{JOIN}, \texttt{CTE}, индексы и т.д.), упрощая оптимизацию и диагностику производительности.
    \item Гибкость: без ограничений \texttt{ORM} можно использовать все возможности \texttt{PostgreSQL}; результаты запросов считываются в типизированные структуры \texttt{Go}.
\end{itemize}
Схема базы данных поддерживается через миграции: каждая версия представлена парой файлов \texttt{*.up.sql} и \texttt{*.down.sql}. Файлы \texttt{up} содержат команды для применения изменений (создание или изменение таблиц и др.), а \texttt{down} — инструкции для отката этих изменений. Миграции нумеруются или метятся по времени, обеспечивая последовательность. Для применения миграций используется утилита \texttt{migrate}, часто запускаемая через \texttt{Docker}. Команда \texttt{migrate up} последовательно применяет все новые скрипты, а \texttt{migrate down} откатывает последние изменения. Такой механизм гарантирует синхронизацию структуры БД во всех средах и позволяет безопасно возвращаться к предыдущей версии.

\texttt{Redis} выполняет роль \texttt{in-memory} хранилища для временных данных и кэша. Для ключей устанавливается время жизни (\texttt{TTL}), что удобно для одноразовых или временных объектов: например, \texttt{SMS}-коды верификации, одноразовые токены или кэшированные результаты. По истечении \texttt{TTL} ключ автоматически удаляется, что упрощает управление памятью. Также ключи разделяются префиксами (например, \texttt{verification:}, \texttt{cache:}, \texttt{session:}) для группировки по функционалу и предотвращения коллизий имён. \texttt{Redis} отлично подходит для сценариев с высокой частотой чтения и короткоживущих данных, например, хранения кодов верификации или кэширования результатов интенсивных запросов.
\begin{itemize}
    \item \texttt{TTL}: ключи с ограниченным сроком жизни; подходит для временных данных (верификационных кодов, сессий), которые автоматически удаляются.
    \item Префиксы ключей: группировка ключей по префиксам (\texttt{otp:}, \texttt{cache:} и др.) упрощает организацию пространства имён и избегает пересечений.
    \item Сценарии использования: кэширование часто запрашиваемых данных и хранение одноразовых верификационных кодов или токенов с коротким сроком действия, обеспечивая быстрый доступ и автоматическое истечение.
\end{itemize}

\subsubsection*{\texttt{NATS JetStream} и брокер}
Обычный \texttt{NATS} — это лёгкий брокер сообщений с поддержкой \texttt{pub/sub}, но без долговременного хранения: сообщения доставляются активным подписчикам мгновенно и затем удаляются (\texttt{at-most-once}). \texttt{JetStream} расширяет возможности \texttt{NATS}, добавляя постоянное хранилище и подтверждение доставки (\texttt{at-least-once}). Сообщения сохраняются на диске в потоках (\texttt{streams}), и потребители должны отправлять подтверждение (\texttt{Ack}). Если сообщение не подтверждено, оно остаётся в потоке и будет доставлено повторно. Благодаря \texttt{JetStream} новые или временно отключённые потребители могут получать пропущенные события, а политика хранения сообщений (сколько хранить и как долго) настраивается централизованно.
\begin{itemize}
    \item Гарантии доставки: \texttt{JetStream} требует явного подтверждения (\texttt{Ack}) от потребителя, обеспечивая хотя бы однократную доставку каждого сообщения.
    \item Хранение сообщений: сообщения сохраняются в потоках (\texttt{Streams}) на диске, что позволяет позднее повторно их считывать и добавлять новых подписчиков.
    \item \texttt{Durable}-подписчики: при использовании долговременных потребителей (\texttt{Durable Consumers}) позиция чтения сохраняется, и при переподключении потребитель продолжает с последнего непрочитанного сообщения.
\end{itemize}
В проекте для работы с \texttt{JetStream} используется официальный клиент \texttt{nats.go}. Отдельный сервис «Broker» отвечает за настройку потоков и подписок. Этот сервис создаёт необходимые \texttt{JetStream}-стримы с заданными политиками хранения и регистрирует \texttt{durable}-консьюмеры для микросервисов. При публикации \texttt{Broker} отправляет сообщения в \texttt{JetStream} и ожидает подтверждения, а при приёме он отдаёт сообщения подписчикам и фиксирует получение. Такой подход обеспечивает надёжный обмен событиями между микросервисами: даже при сбоях или перезапусках ничего не теряется.

\subsubsection*{\texttt{JWT} и безопасность}
\texttt{JWT (JSON Web Token)} состоит из трёх частей: \texttt{header}, \texttt{payload} и \texttt{signature}. \texttt{Header} определяет метаданные токена (например, алгоритм \texttt{HS256} и тип), \texttt{payload} содержит утверждения (\texttt{claims}) — стандартные (\texttt{iss}, \texttt{exp}, \texttt{sub}, \texttt{iat} и др.) и пользовательские (например, идентификатор пользователя). \texttt{Signature} формируется с помощью \texttt{HMAC SHA-256}: это результат применения \texttt{HMAC} к \texttt{base64}-закодированным \texttt{header} и \texttt{payload} с использованием секретного ключа. Такой механизм обеспечивает целостность: при любой подмене данных подпись не пройдёт проверку.
\begin{itemize}
    \item \texttt{Header}: задаёт алгоритм подписи (\texttt{HS256}) и тип токена (\texttt{JWT}).
    \item \texttt{Payload}: содержит информацию о пользователе и сроке действия (например, поле \texttt{exp} с временем истечения).
    \item \texttt{Signature}: \texttt{HMAC SHA-256} по содержимому \texttt{header} и \texttt{payload} с секретом, гарантирующий неизменность токена.
\end{itemize}
При обработке запроса AuthService извлекает \texttt{JWT} из заголовка (обычно \\ Authorization: Bearer). Сначала декодируются \texttt{header} и \texttt{payload} (из \texttt{base64}), затем проверяется подпись с использованием известного секретного ключа. Если подпись верна и не истёк срок действия (claim \texttt{exp}), токен считается валидным. Так как используется \texttt{HMAC (HS256)}, для проверки подписи не требуется обращение к внешним сервисам — достаточно владения ключом.
\begin{itemize}
    \item \texttt{HS256}: симметричный алгоритм \texttt{HMAC SHA-256} с секретным ключом для подписи и проверки.
    \item Валидация: сервис проверяет подпись, а также проверяет временные поля (\texttt{exp}, \texttt{nbf}), принимая или отвергая токен на основе этих данных.
\end{itemize}
В токен дополнительно включается так называемый \texttt{fingerprint} — уникальная метка клиента (например, хэш браузерного отпечатка или случайный идентификатор сессии). При валидации \texttt{AuthService} сверяет этот \texttt{fingerprint} с данными запроса (например, с текущим \texttt{User-Agent}). Это повышает устойчивость к перехвату: даже если \texttt{JWT} украдут, без совпадающего \texttt{fingerprint}-а (то есть без соответствующего клиентского окружения) токен будет считаться недействительным.
\begin{itemize}
    \item Привязка к \texttt{fingerprint}: в токен добавляется метка устройства или сессии; при проверке сервис сверяет её с фактической информацией клиента, препятствуя использованию токена на другом устройстве.
\end{itemize}

\subsubsection*{\texttt{bcrypt}}
Для хранения паролей используется алгоритм \texttt{bcrypt}. \texttt{Bcrypt} применяет соль и настраиваемый параметр сложности (\texttt{cost}). При создании пользователя \texttt{bcrypt} генерирует случайную соль и комбинирует её с паролем, а затем многократно вычисляет хеш. Количество раундов (\texttt{cost}) задаёт, насколько медленным будет вычисление: чем выше значение, тем дольше генерируется хеш. В результате одна и та же комбинация пароля и соли всегда даёт один и тот же хеш, но каждый раз \texttt{bcrypt} генерирует новую соль и новый хеш, что исключает повторяемость.
\begin{itemize}
    \item Соль: автоматическая случайная соль для каждого пароля предотвращает атаки по заранее скомпилированным словарям (радужным таблицам).
    \item Количество раундов: параметр сложности (\texttt{cost}) определяет число итераций; увеличенный \texttt{cost} значительно замедляет процесс хеширования, затрудняя подбор пароля.
    \item Невозможность обратного вычисления: \texttt{bcrypt} — односторонняя функция. Имея только хеш, невозможно извлечь исходный пароль, что защищает данные в случае компрометации хешей.
\end{itemize}
\texttt{Bcrypt} предпочтительнее быстрых хешей (\texttt{MD5}, \texttt{SHA-256}) для паролей, поскольку специально разработан для медленного хеширования. Быстрые алгоритмы (\texttt{MD5}, \texttt{SHA-256}) без соли уязвимы к современным атакам, так как их вычисление очень быстрое на современных \texttt{GPU}. \texttt{Bcrypt} же с солью и регулируемым \texttt{cost} устойчив к таким атакам, поэтому считается стандартом для безопасного хранения паролей. 

Использование единого технологического стека (\texttt{Go}, \texttt{gRPC}, PostgreSQL, Redis, NATS JetStream и др.) существенно снижает накладные расходы на разработку и сопровождение. Единый язык и инструментарий упрощают обучение команды, позволяют переиспользовать компоненты (логгеры, генерацию кода, шаблоны конфигураций) и стандартизировать процессы \texttt{CI/CD}. Благодаря согласованной архитектуре микросервисы легко масштабируются: все сервисы работают по одинаковым принципам и протоколам, поэтому можно быстро развертывать новые экземпляры и интегрировать дополнительную функциональность. В итоге однородный стек технологий делает систему «Путешествия по России» более предсказуемой, надёжной и удобной в сопровождении.


\subsection*{3.2 Реализация микросервисов}
\addcontentsline{toc}{subsection}{3.2 Реализация микросервисов}

Система спроектирована по принципу слабосвязанной, модульной архитектуры: каждый сервис отвечает за отдельную доменную область и может масштабироваться независимо. Обмен сообщениями между сервисами осуществляется через \texttt{gRPC}-вызовы (все \texttt{гRPC}-запросы маршрутизируются через \texttt{API-Gateway Envoy}), а асинхронные события обрабатываются посредством брокера сообщений \texttt{NATS JetStream}. Хранилищем данных выступают \texttt{PostgreSQL} (для большинства сервисов), \texttt{Redis} (для кэша и хранения токенов), \texttt{MinIO} (\texttt{S3}-совместимое хранилище файлов); внешним почтовым сервисом служит \texttt{Brevo (SendinBlue)} для отправки электронной почты.

\subsubsection*{Auth Service}
Назначение: Сервис аутентификации и авторизации отвечает за регистрацию пользователей, проверку их учётных данных и управление \texttt{JWT}-токенами (\texttt{OAuth2.0}). Он обеспечивает создание новых учётных записей, выдачу и обновление токенов доступа и обновления (\texttt{refresh tokens}), а также валидацию токенов при запросах к другим сервисам.

Основные бизнес-задачи: регистрация (\texttt{SignUp}), вход (\texttt{SignIn}), выход (\texttt{Logout}), обновление токенов (\texttt{RefreshToken}), проверка валидности токена (\texttt{ValidateToken}). При регистрации выполняется проверка уникальности \texttt{email}, хеширование пароля (\texttt{bcrypt/Argon2}), сохранение пользователя в БД и установка статуса учётной записи. При успешной регистрации сервис публикует событие о новом пользователе в шину \texttt{NATS JetStream} (топик \\ EmailEventsService) для последующей отправки приветственного письма через сервис уведомлений. При логине проверяются \texttt{email} и пароль пользователя, после чего генерируются \texttt{JWT} (доступа) и токен обновления. Сами \texttt{refresh}-токены сохраняются в \texttt{Redis (Auth Cache)} с привязкой к пользователю для возможности проверки/отзыва. При запросе на обновление токена сервис проверяет валидность переданного \texttt{refresh}-токена (существует ли он в \texttt{Redis} и не истёк ли), генерирует новые токены. При \texttt{logout} — удаляет \texttt{refresh}-токен из \texttt{Redis} или помечает его аннулированным. Для повышения безопасности сервис ограничивает длину и формат входных данных, возвращая \texttt{INVALID\_ARGUMENT}, если аргументы некорректны.

\texttt{gRPC}-методы и логика:
\begin{itemize}
    \item \texttt{RegisterUser} (регистрация): принимает \texttt{email} и пароль. Сначала проверяет, что \texttt{email} имеет корректный формат и в БД пока нет пользователя с таким \texttt{email}. Если дублирование обнаружено, возвращает ошибку \texttt{ALREADY\_EXISTS}. В случае отсутствия конфликта создаёт запись в таблице \texttt{users} (см. рис. 3.3–2) и устанавливает статус пользователя «active». После сохранения отправляет событие в \texttt{NATS} для рассылки \texttt{email}. Возвращает статус \texttt{OK} или \texttt{INTERNAL\_ERROR} при ошибке БД.
    \item \texttt{LoginUser} (вход): получает \texttt{email} и пароль. Ищет пользователя в БД; если не найден — возвращает \texttt{NOT\_FOUND}; если пароль неверен — возвращает \texttt{UNAUTHENTICATED}. При успехе генерирует \texttt{JWT} и \texttt{refresh}-токен, сохраняет \texttt{refresh}-токен в \texttt{Redis} (\texttt{TTL} согласно настройкам) и возвращает токены.
    \item \texttt{RefreshToken}: на вход получает старый \texttt{refresh}-токен. Проверяет его наличие в \texttt{Redis}: если отсутствует или истёк — возвращает \\ UNAUTHENTICATED, иначе удаляет старый и выдаёт новую пару токенов (новый \texttt{refresh} также сохраняется в \texttt{Redis}).
    \item \texttt{ValidateToken}: принимает \texttt{JWT}, декодирует и проверяет подпись и срок. Если токен невалиден или истёк — возвращает \texttt{UNAUTHENTICATED}, иначе возвращает успех.
    \item При необходимости могут быть методы \texttt{Logout} (удаление \texttt{refresh}-токена) и \texttt{RevokeToken}. Все методы обрабатывают ошибки невалидных аргументов (\texttt{INVALID\_ARGUMENT}), ошибки БД (\texttt{INTERNAL}) и нарушения бизнес-правил (дублирование — \texttt{ALREADY\_EXISTS}, отсутствие ресурса — \texttt{NOT\_FOUND}).
\end{itemize}
Архитектура и организация кода: Сервис реализован на \texttt{Go} по принципам «чистой архитектуры». Слои разделены следующим образом: уровень \texttt{Domain} описывает сущность \texttt{User} и её бизнес-логику, уровень \texttt{Repository} (интерфейс и реализация) взаимодействует с \texttt{PostgreSQL} и \texttt{Redis}, уровень \texttt{Usecase} реализует сценарии (регистрация, логин и др.), слой \texttt{Delivery} содержит \texttt{gRPC}-сервер и переводит входящие протоколы \texttt{Protobuf} в доменные структуры. В корне пакета определены интерфейсы (файлы \texttt{repository.go}, \texttt{usecase.go}), а в подпакетах (\texttt{/repository}, \texttt{/usecase}, \texttt{/delivery}) находятся их реализации и обработчики. При запуске сервиса происходит конфигурация соединений с БД и \texttt{Redis}, настройка \texttt{gRPC}-сервера (регистрация методов \texttt{AuthServiceServer} из \texttt{protobuf}), а также настройка клиента \texttt{NATS} для публикации событий. Все зависимости (доступ к БД, брокеру сообщений и прочему) внедряются через параметры конструкторов (\texttt{Dependency Injection}) для слабой связанности и удобства тестирования.

Работа с базой и кэшем: \texttt{AuthService} использует \texttt{PostgreSQL} для хранения учётных записей и статус пользователей. Для хранения активных \texttt{refresh}-токенов применяется \texttt{Redis}, позволяющий быстро валидировать токены и осуществлять их отзыв (удаление при \texttt{logout}). Таблица \texttt{users} имеет уникальный индекс по полю \texttt{email} — при попытке регистрации существующего \texttt{email} будет выброшена ошибка \texttt{ALREADY\_EXISTS} (код 6).

Взаимодействие с другими сервисами: после создания учётной записи \texttt{AuthService} генерирует событие о регистрации и публикует его в \texttt{NATS JetStream} (топик \texttt{EmailEventsService}). Сервис \texttt{Notifications} подписан на этот топик и при получении события отправляет пользователю письмо через \texttt{Brevo}. Также сервис \texttt{Auth} может выполнять вызов \texttt{CreateProfile} в \texttt{ProfileService} (\texttt{гRPC}-вызов \texttt{profile.ProfileService}), чтобы автоматически создать связанную запись профиля при регистрации (например, с начальным именем и аватаром по умолчанию). Такой вызов производится синхронно по \texttt{gRPC} и при возникновении ошибок взаимодействия возвращает \texttt{FAILED\_PRECONDITION} или \texttt{UNAVAILABLE}. При аутентификации запросы клиентов требуют действительного \texttt{JWT}, который проверяется во всех сервисах через встроенную логику \texttt{AuthService} (или встроенным \texttt{middleware}), генерируя \texttt{UNAUTHENTICATED} для невалидного/просроченного токена.

\subsubsection*{Profile Service}
Назначение: Сервис профилей отвечает за хранение и управление пользовательскими профилями, включая информацию о имени (\texttt{username}), ФИО, дате рождения, аватаре, а также за реализацию подписок (\texttt{follow/unfollow}) между пользователями.

Основные бизнес-задачи: хранение данных профиля, поддержка уникальности \texttt{username}, обработка действий «подписаться/отписаться» между пользователями. Сюда входят операции создания/чтения/обновления/удаления профиля (\texttt{CRUD}), изменение аватара, поиск профилей, а также ведение таблицы подписчиков. При создании нового профиля сервис проверяет, что \texttt{username} уникален (уникальный индекс), и сохраняет новую запись, связывая её с \texttt{user\_id} из \texttt{AuthService}. При обновлении профиля возможно изменение поля \texttt{username} (тоже с проверкой уникальности) и загрузка нового аватара. Для загрузки/получения файла аватара сервис обращается к \texttt{FileStorageService} через \texttt{gRPC}. Например, метод \texttt{UploadAvatar} (реализованный во \texttt{FileStorage}) вызывается из \texttt{ProfileService}: он возвращает \texttt{ID} файла, который затем сохраняется в поле \texttt{profiles.image\_id}. Поля \texttt{followers\_count} и \texttt{following\_count} автоматически обновляются при операциях подписки.

В качесте базы данных используется \texttt{PostgreSQL} с двумя таблицами: таблица \texttt{profiles} (поля \texttt{user\_id (PK,UUID)}, \texttt{username}, \texttt{first\_name}, \texttt{last\_name}, \\ \texttt{date\_of\_birth}, \texttt{image\_id}, счетчики подписок, метки времени) и связная таблица \texttt{follows} (\texttt{follower\_id}, \texttt{followed\_id}). Поле \texttt{username} имеет уникальное ограничение, поэтому в случае конфликта возвращается \texttt{ALREADY\_EXISTS}.

\texttt{gRPC}-методы и логика:
\begin{itemize}
    \item \texttt{CreateProfile}: получает \texttt{user\_id} (из \texttt{Auth}), \texttt{username}, ФИО и др. Проверяет заполнение обязательных полей; если \texttt{username} занят — возвращает \texttt{ALREADY\_EXISTS}. Далее создает запись в \texttt{profiles}. Ошибки БД обрабатываются как \texttt{INTERNAL}.
    \item \texttt{GetProfile}: по \texttt{user\_id} или \texttt{username} извлекает данные профиля. Если профиль не найден — возвращает \texttt{NOT\_FOUND}. Может возвращать публичную информацию (без паролей).
    \item \texttt{UpdateProfile}: обновляет имя, фамилию, дату рождения; при смене \\ \texttt{username} повторяет проверку уникальности (\texttt{ALREADY\_EXISTS} при дублировании). Если указана загрузка нового аватара, получает от клиента поток байтов и передает его во \texttt{FileStorageService} (см. ниже). При успехе возвращает обновленный профиль. Ошибки валидации аргументов дают \texttt{INVALID\_ARGUMENT}.
    \item \texttt{DeleteProfile}: удаляет запись профиля и связанные данные (например, обнуляет подписки). Если профиль не найден — \texttt{NOT\_FOUND}.
    \item \texttt{FollowUser}: принимает \texttt{follower\_id} и \texttt{followed\_id}. Проверяет, что оба профиля существуют (вызов \texttt{GetProfile}). Нельзя подписаться на себя — приводит к \texttt{FAILED\_PRECONDITION}. Если подписка уже существует, возвращает \texttt{ALREADY\_EXISTS}. Иначе создает запись в таблице \texttt{follows} и инкрементирует счетчики \texttt{followers\_count/following\_count} в таблице \texttt{profiles}.
    \item \texttt{UnfollowUser}: обратная операция; если записи нет — возвращает\\ \texttt{NOT\_FOUND}, иначе удаляет подписку и декрементирует счетчики.
    \item \texttt{ListFollowers/ListFollowing}: возвращают список пользователей по запросу; возвращают пустой список, если подписчиков нет.
    \item \texttt{UploadAvatar} (в сотрудничестве с \texttt{FileStorageService}): клиент передаёт бинарный поток файла; \texttt{ProfileService} может выступать прокси или просить \texttt{FileStorageService} сгенерировать \texttt{presigned URL}. После загрузки файл регистрируется в таблице \texttt{files FileStorage}, а \texttt{ID} сохраняется в \texttt{profiles.image\_id}. При некорректных файлах (слишком большой размер, неподдерживаемый формат) возвращается \texttt{INVALID\_ARGUMENT} или \texttt{RESOURCE\_EXHAUSTED}.
\end{itemize}
Архитектура: Сервис разбит по «чистой архитектуре» на слои: доменная модель \texttt{Profile (domain)}, интерфейсы репозитория и \texttt{usecase} (catalog of business logic), реализации (\texttt{persistence} с использованием \texttt{SQL}), а также слой доставки (\texttt{гRPC handlers}). Например, в корне модуля определён интерфейс \\ \texttt{ProfileRepository} (\texttt{CRUD}-операции над \texttt{profiles/follows}) и интерфейс \texttt{ProfileUsecase} с методами вроде \texttt{CreateProfile}, \texttt{FollowUser} и т. д., а соответствующие имплементации находятся в подпакетах \texttt{repository} и \texttt{usecase}. Слой \texttt{Delivery} реализует \texttt{gRPC}-сервер (generated из \texttt{protobuf}) и преобразует входящие запросы в вызовы \texttt{usecase}. Такой подход гарантирует независимость бизнес-логики от конкретного хранилища и протокола, упрощает тестирование и замену компонентов.

Взаимодействие: \texttt{ProfileService} получает \texttt{user\_id} от \texttt{AuthService} (обычно через метаданные \texttt{gRPC/токен}). При создании профиля \texttt{AuthService} инициирует \texttt{gRPC}-вызов \texttt{CreateProfile} в \texttt{ProfileService} для добавления записи. \\ \texttt{ProfileService} обращается к \texttt{FileStorageService (filestorage.FileStorageService)} для работы с аватаром: при загрузке пользователя на уровне \texttt{usecase} вызывается метод для генерации \texttt{PresignedURL} или непосредственной передачи файла. Ответы от \texttt{FileStorage} возвращают либо \texttt{ID} файла, либо ошибку (\texttt{NotFound}, если хранилище недоступно). \texttt{ProfileService} не публикует событий в \texttt{NATS} напрямую (логика подписок обрабатывается синхронно), однако при необходимости можно расширить систему на события (например, оповещения через \\ \texttt{Notifications} при новых подписках).

\subsubsection*{Activity Service}
Назначение: Сервис активности реализует функциональность «лайки», «комментарии» и подсчета статистики по контенту. Он связывает пользователей и туристический контент (маршруты) в терминах социального взаимодействия.

Основные бизнес-задачи: добавление/удаление лайков к маршруту, публикация комментариев к маршруту, асинхронное обновление счётчиков лайков/комментариев. Например, пользователь может поставить лайк маршруту — \texttt{ActivityService} сохраняет соответствующую запись в БД. Аналогично создаются записи комментариев. Сервис также обеспечивает получение списка комментариев и информации о лайках. В системе реализовано асинхронное обновление агрегированных счётчиков: после изменения лайка или комментария сервис публикует событие в \texttt{NATS}, которое обрабатывает вспомогательный компонент (\texttt{ActivityCountersService}) для обновления общих счетчиков в БД \texttt{ContentService}. Это позволяет снизить нагрузку и обеспечить \texttt{eventual consistency}.

База данных: \texttt{PostgreSQL} с таблицами: \texttt{route\_likes} (поля \texttt{route\_id}, \texttt{user\_id}, метка и времени): и \texttt{route\_comments} (\texttt{comment\_id PK}, \texttt{route\_id}, \texttt{user\_id}, \texttt{text}, \texttt{created\_at}). Каждая запись лайка уникальна по паре (\texttt{route\_id}, \texttt{user\_id}). При попытке поставить повторный лайк должна сработать проверка уникальности. 

\texttt{gRPC}-методы и логика:
\begin{itemize}
    \item \texttt{AddLike}: получает \texttt{route\_id} и \texttt{user\_id}. Сервис сначала проверяет, что маршрут существует (вызывая метод \texttt{GetRoute} из \texttt{ContentService}); если нет — возвращает \texttt{NOT\_FOUND}. Затем пытается вставить запись в \texttt{route\_likes}. Если такая запись уже есть (пользователь уже лайкал) — возвращает \texttt{ALREADY\_EXISTS}. Иначе сохраняет лайк и публикует событие \texttt{LikeAdded} в \texttt{NATS JetStream} (содержит \texttt{route\_id}), чтобы обновить счётчик лайков.
    \item \texttt{RemoveLike}: удаляет запись лайка. Если записи нет — \texttt{NOT\_FOUND}. После удаления публикуется событие \texttt{LikeRemoved}.
    \item \texttt{AddComment}: принимает \texttt{route\_id}, \texttt{user\_id}, текст. Проверяет существование пользователя (\texttt{ProfileService}) и маршрута (\texttt{ContentService}). Вставляет запись в \texttt{route\_comments} с новым \texttt{comment\_id}. Если текст пустой или слишком длинный — \texttt{INVALID\_ARGUMENT}. При успехе публикует событие \texttt{CommentAdded}.
    \item \texttt{DeleteComment}: удаляет свой комментарий (по \texttt{comment\_id}). Если не найден или не принадлежит пользователю — \texttt{NOT\_FOUND} или \\ \texttt{PERMISSION\_DENIED}.
    \item \texttt{ListComments}: возвращает список комментариев по маршруту. Если маршрута нет — \texttt{NOT\_FOUND}.
    \item \texttt{GetLikeCount/GetCommentCount}: может возвращать текущие счётчики. Эти данные можно либо поддерживать в памяти (посчитать при запросе), либо получать из агрегированной таблицы/кэша, обновляемой с помощью \texttt{NATS}-событий.
\end{itemize}
В упомянутых методах используются стандартные коды ошибок \texttt{gRPC}: \\ \texttt{NOT\_FOUND} при отсутствии ресурса, \texttt{ALREADY\_EXISTS} при попытке дублирования (например, лайка), \texttt{INVALID\_ARGUMENT} при ошибках валидации, \\ если пользователь не авторизован — UNAUTHENTICATED,  и \texttt{PERMISSION\_DENIED} при попытке удалить чужой комментарий.

Архитектура: Чистая архитектура: доменные сущности «Like» и «Comment», репозиторий для \texttt{CRUD}-операций над таблицами (\texttt{PostgreSQL}), \texttt{usecase}-слой для бизнес-логики (проверка существования маршрута/пользователя, транзакции вставки/удаления, публикация событий), слой доставки \texttt{gRPC}. В модуле определены интерфейсы \texttt{ActivityRepository} и \texttt{ActivityUsecase}, их реализации и \texttt{gRPC}-хендлеры. Очистка кода и тестируемость обеспечиваются тем, что работа с БД и внешними сервисами (\texttt{ContentService}, \texttt{ProfileService}, \texttt{NATS}) инвертирована через интерфейсы.

Работа с \texttt{NATS}: Каждый раз при изменении лайков или комментариев сервис публикует событие в \texttt{JetStream}. Например, после успешной вставки лайка отправляется сообщение «LikeAdded» (с \texttt{JSON}- или \texttt{Protobuf}-данными). Другой поток (\texttt{ActivityCountersService}) подписан на эти события и обновляет агрегированные счётчики в таблице маршрутов или отдельном хранилище. Такой подход гарантирует, что тяжёлые операции обновления статистики выполняются асинхронно, а базовая транзакция обработки лайка/комментария остаётся простой и быстрой. 

Взаимодействие: при добавлении лайка или комментария \texttt{ActivityService} обращается к \texttt{ContentService (content.ContentService)} для проверки существования маршрута, а к \texttt{ProfileService (profile.ProfileService)} для проверки пользователя (определение его прав). Эти вызовы \texttt{gRPC} инкапсулированы в \texttt{usecase} (например, интерфейсы \texttt{ContentClient}, \texttt{ProfileClient}). Обмен сообщениями с \texttt{FileStorageService} или \texttt{Notifications} здесь не происходит напрямую (если только при расширении системы делать уведомления об активности).

\subsubsection*{Content Service}
Назначение: Сервис контента отвечает за хранение и управление туристическим контентом: маршрутами (\texttt{routes}) и достопримечательностями/местами (\texttt{places}). Он предоставляет \texttt{CRUD}-операции над маршрутами (название, сложность, дистанция, координаты точек) и местами (имя, адрес, описание, координаты). Кроме того, организована поддержка связывания мест с маршрутами в заданном порядке и прикрепления мультимедийных файлов (изображений) к этим сущностям.

Основные бизнес-задачи: добавление, обновление, удаление и поиск маршрутов и мест, фильтрация маршрутов по параметрам (например, сложности), изменение последовательности точек пути. Каждому маршруту может соответствовать несколько мест (через промежуточную таблицу \texttt{route\_places}), и у каждого места может быть несколько изображений (таблица \texttt{place\_files}). Сервис обеспечивает консистентное хранение геоданных (\texttt{latitude/longitude}) и поддерживает транзакции при изменении маршрутов и связанных объектов. Также реализован \texttt{gRPC} метод потоковой передачи (\texttt{stream}) для загрузки/выгрузки изображений: например, клиент может вызывать метод \\ \texttt{UploadPlaceImage} как поток данных, который на стороне сервиса перенаправляется в \\ \texttt{FileStorageService} для сохранения в \texttt{MinIO}.

База данных: \texttt{PostgreSQL} с таблицами (см. рис. 3.3–5):
\begin{itemize}
    \item \texttt{routes (id UUID, name, difficulty, distance, массивы координат \\ latitudes/longitudes, user\_id владельца, метки времени, описание)}.
    \item \texttt{places (id UUID, name, address, description, latitude, longitude, метки времени)}.
    \item Связующая таблица \texttt{route\_places (route\_id, place\_id, ordering для порядка следования)}.
    \item Таблица \texttt{files} (используется \texttt{FileStorageService}) и \texttt{place\_files (place\_id, file\_id, ordering)} для привязки файлов-изображений к месту.
\end{itemize}
Для каждой таблицы определены первичные ключи и необходимые индексы. В таблице \texttt{routes} поле \texttt{name} может иметь составной уникальный индекс (например, уникальность имени маршрута для одного пользователя). Схема организации данных позволяет эффективно фильтровать и выполнять геозапросы (через \texttt{SQL} или \texttt{PostGIS} расширения).

\texttt{gRPC}-методы и логика:

Маршруты:
\begin{itemize}
    \item \texttt{CreateRoute}: принимает параметры маршрута (имя, сложность, дистанцию, координаты, описание, \texttt{user\_id}). Проверяет обязательные поля (имя, хотя бы одну координату и пр.); если имя уже занято у данного пользователя — возвращает \texttt{ALREADY\_EXISTS}. Создаёт новую запись в \texttt{routes}, сохраняет массивы координат. При добавлении начальных мест может выполнять дополнительные вставки в \texttt{route\_places}.
    \item \texttt{GetRoute}: по \texttt{route\_id} возвращает структуру маршрута со всеми полями и списком связанных мест (с учётом поля \texttt{ordering}). Если маршрут не найден — \texttt{NOT\_FOUND}.
    \item \texttt{UpdateRoute}: обновляет свойства маршрута (может менять имя, сложность, описание и т. д.); проверяет наличие записи; если маршрут с новым именем конфликтует — \texttt{ALREADY\_EXISTS}. Для изменения путевых точек может реализовываться несколько методов (например, \\ \texttt{SetRoutePlaces}), которые обновляют \texttt{route\_places} (добавление/удаление мест).
    \item \texttt{DeleteRoute}: удаляет маршрут и все связанные записи (места к маршруту, файлы). При отсутствии записи — \texttt{NOT\_FOUND}.
    \item \texttt{ListRoutes}: возвращает список маршрутов с возможными фильтрами (например, по сложности, по географическому диапазону). Если фильтр указан некорректно — \texttt{INVALID\_ARGUMENT}.
\end{itemize}
Места (\texttt{Places}):
\begin{itemize}
    \item \texttt{CreatePlace/GetPlace/UpdatePlace/DeletePlace}: аналогичные \\ CRUD-операции для объектов \texttt{places}. При создании указывается имя, адрес, координаты.
    \item \texttt{AddPlaceToRoute/RemovePlaceFromRoute}: связывают место с маршрутом. Если \texttt{route\_id} или \texttt{place\_id} не найдены — \texttt{NOT\_FOUND}. При добавлении проверяется, что такая связь ещё не существует (иначе \\ \texttt{ALREADY\_EXISTS}), и задаётся порядок следования.
\end{itemize}
Изображения (\texttt{Media}):
\begin{itemize}
    \item \texttt{UploadPlaceImage (stream)}: потоковое получение бинарных данных изображения от клиента. \texttt{ContentService} принимает потоки (\texttt{Chunked gRPC}) и переадресует данные во \texttt{FileStorageService}: либо получает от него \texttt{Presigned URL} (и сам загружает через \texttt{HTTP}), либо напрямую вызывает \texttt{UploadFile gRPC}. После успешной загрузки сервис получает идентификатор файла (из \texttt{FileStorage}) и создаёт запись в \texttt{place\_files} с \texttt{place\_id} и \texttt{file\_id}. Если файл по размеру превышает лимит — \\ \texttt{RESOURCE\_EXHAUSTED}.
    \item \texttt{GetPlaceImage (stream)}: загрузка изображения с помощью \texttt{gRPC}-стрима из \texttt{FileStorageService} по \texttt{file\_id} и транслирование клиенту. Если файл отсутствует — \texttt{NOT\_FOUND}.
\end{itemize}
Таким образом, большинство \texttt{gRPC}-методов \texttt{ContentService} оборачивает стандартные \texttt{CRUD}-операции над \texttt{SQL}, дополняя их необходимыми проверками и вызовами внешнего сервиса для работы с файлами. При этом используется унифицированный паттерн обработки ошибок: \texttt{NOT\_FOUND} для отсутствующих записей, \texttt{ALREADY\_EXISTS} для дубликатов, \texttt{INVALID\_ARGUMENT} при некорректных входных данных.

Архитектура: как и в других сервисах, применена «чистая архитектура»: в пакете \texttt{content} определены доменные модели \texttt{Route} и \texttt{Place}, интерфейсы репозитория и \texttt{usecase} (файлы \texttt{repository.go}, \texttt{usecase.go} на верхнем уровне) и их реализации в подпакетах. Layer \texttt{usecase} инкапсулирует основную логику (создание маршрутов, валидация координат, связывание с файлами), слой \texttt{repository} (например, \texttt{PostgresRepository}) выполняет \texttt{SQL}-запросы к таблицам. Слой \texttt{Delivery} реализован \texttt{gRPC}-сервер: все обработчики принимают \texttt{Protobuf}-запросы и вызывают методы \texttt{usecase}. Такой подход отделяет бизнес-логику от инфраструктуры (БД, протокол коммуникации).

Работа с файловым сервисом и хранением: для работы с изображениями \texttt{ContentService} взаимодействует с \texttt{FileStorageService}. В момент загрузки изображения сервис запрашивает у \texttt{FileStorage presigned URL} или использует \texttt{gRPC}-метод загрузки. Ответ от \texttt{FileStorage} возвращает \texttt{file\_id}, который связывается с \texttt{place\_id} в таблице \texttt{place\_files}. \texttt{MinIO} настроен как \texttt{S3}-совместимое хранилище; \texttt{FileStorage} контролирует \texttt{TTL} для файлов и шифрование. API-Gateway (Envoy) перенаправляет \texttt{HTTP}-запросы по \texttt{presigned URL} напрямую в \texttt{MinIO}, что разгружает сервис от передачи больших бинарных файлов.

Взаимодействие с другими сервисами: \texttt{ContentService} может вызывать методы \texttt{ProfileService} (например, для получения информации о владельце маршрута) и \texttt{ActivityService} (для получения количества лайков/комментариев), но в минимальной конфигурации такого нет. В основном другие сервисы обращаются к \texttt{ContentService}: \texttt{ActivityService} — для проверки существования маршрута, \texttt{ProfileService} — при необходимости искать маршруты по \texttt{user\_id}, \texttt{AuthService} — при проверке прав владельца, и \texttt{FileStorageService} — для загрузки файлов. После модификации контента сервис может публиковать события (например, «RouteCreated» или «PlaceAdded») в \texttt{NATS} для дальнейшей обработки или обновления кэшей, однако базовые операции сконцентрированы на синхронной \texttt{CRUD}-логике.

\subsubsection*{FileStorage Service}
Назначение: Сервис управления файлами обеспечивает надёжную загрузку, хранение и выдачу медиафайлов (изображений, аватаров и т. д.) в систему. Он выступает как прослойка между микросервисами и объектным хранилищем \texttt{MinIO}, реализуя политику безопасности, ограничения по размеру, \texttt{TTL} (время жизни) и шифрование файлов.

Основные бизнес-задачи: приём файлов от клиентов или других сервисов, сохранение их в \texttt{MinIO}, хранение метаданных в БД, выдача файлов по запросу, управление сроком жизни (\texttt{TTL}) и правами доступа. Также \texttt{FileStorage} генерирует \texttt{presigned URL}, позволяющие клиентам напрямую загружать или скачивать файлы через \texttt{MinIO} по \texttt{HTTP} (через \texttt{API Gateway}).

База данных: \texttt{PostgreSQL} с таблицей \texttt{files} (пример на рис. 3.3–3 и 3.3–5). Поля: \texttt{id (integer, PK)}, \texttt{file\_name}, \texttt{storage\_bucket}, \texttt{storage\_id} (идентификатор в \texttt{MinIO}), \texttt{internal\_url}, \texttt{placeholder} (для превью), \texttt{size}, флаги доступа (\texttt{from\_public}), метки времени. Эта таблица хранит метаданные загруженных файлов. Первичный ключ — целочисленный \texttt{id}.

\texttt{gRPC}-методы и логика:
\begin{itemize}
    \item \texttt{UploadFile (stream)}: клиент передаёт байтовый поток файла. Сервис накапливает полученные данные, проверяет, чтобы общий размер не превышал предельный (например, 10 MB); если превышает, прерывает с кодом \texttt{RESOURCE\_EXHAUSTED}. Данные шифруются на лету (используется серверная сторона \texttt{MinIO} или \texttt{KMS}) и отправляются в заданный бакет \texttt{MinIO}. После завершения загрузки генерируется запись в таблице \texttt{files} с метаданными (имя, размер, \texttt{internal\_url} и пр.) и возвращается \texttt{id} файла. Если запись с таким именем уже есть — \texttt{ALREADY\_EXISTS}. При любых внутренних ошибках возвращается \texttt{INTERNAL}.
    \item \texttt{DownloadFile (stream)}: клиент запрашивает файл по \texttt{id}. Сервис находит запись в БД; если нет — \texttt{NOT\_FOUND}. Далее запрашивает файл из \texttt{MinIO} и передаёт данные клиенту по \texttt{gRPC}-стриму. Если файл удалён или повреждён — возвращает \texttt{NOT\_FOUND} или \texttt{INTERNAL}.
    \item \texttt{GetPresignedUploadURL}: по запросу с названием файла возвращает клиенту подписанный \texttt{URL} для загрузки (\texttt{HTTP PUT}) непосредственно в \texttt{MinIO}. Срок действия \texttt{URL} ограничен \texttt{TTL} (например, 15 минут). Это позволяет разгрузить сервис от передачи больших файлов через \texttt{gRPC}.
    \item \texttt{GetPresignedDownloadURL}: аналогично выдаёт \texttt{URL} для скачивания (\texttt{HTTP GET}).
    \item \texttt{DeleteFile}: удаляет запись из БД и файл из \texttt{MinIO}. Если файла нет — \texttt{NOT\_FOUND}.
\end{itemize}
Архитектура: Сервис организован по слоям: доменная модель \texttt{File} с методами (например, метод проверки размера), репозиторий для работы с \texttt{PostgreSQL}, \texttt{usecase}-слой, и слой доставки \texttt{gRPC}. Используются интерфейсы для абстракции работы с \texttt{MinIO} (например, \texttt{FileStorageClient}) и для доступа к БД. Шифрование файлов осуществляется через встроенные механизмы \texttt{MinIO (Server-Side Encryption)} или путем шифрования байтов перед отправкой. Политика \texttt{TTL} задаётся либо на стороне \texttt{MinIO} (правила удаления после X дней), либо самим сервисом (отмечая метку времени в БД и периодически удаляя устаревшие файлы, используя внутренний \texttt{scheduler} или события \texttt{NATS}).

Интеграция с другими сервисами: \texttt{ProfileService} и \texttt{ContentService} обращаются к \texttt{FileStorageService} при необходимости загрузки или получения файлов: они могут использовать \texttt{gRPC}-методы загрузки либо \texttt{presigned URL}. Например, при смене аватара \texttt{ProfileService} запрашивает \texttt{GetPresignedUploadURL}, получает ссылку и отправляет файл напрямую в \texttt{MinIO}. Либо вызывает \texttt{UploadFile} с передачей потока. После получения \texttt{file\_id} записывает его в профиль. \\ \texttt{ContentService} поступает аналогично для изображений мест. \texttt{API Gateway (Envoy)} перенаправляет запросы по \texttt{presigned URL} напрямую в \texttt{MinIO}. \texttt{FileStorageService} также публикует события об удалении старых файлов в \texttt{NATS} (для логирования или обратного оповещения других компонентов). Ошибки взаимодействия (например, \texttt{NOT\_FOUND} при запросе несуществующего файла) обрабатываются по стандарту \texttt{gRPC}.

\subsubsection*{Notifications Service}
Назначение: Сервис уведомлений занимается отправкой электронных сообщений пользователям системы через сторонний \texttt{SMTP/API} сервис \texttt{Brevo (SendinBlue)}. Он реагирует на события, публикуемые другими микросервисами в \texttt{NATS JetStream}, и превращает их в \texttt{email}-уведомления (регистрация, смена пароля, действия в приложении и т. д.).

Основные бизнес-задачи: подписка на топики событий \texttt{NATS} (например, \texttt{UserRegistered}, \texttt{PasswordReset}, \texttt{CommentAdded}), формирование писем по заранее заданным шаблонам и отправка их через \texttt{REST API Brevo}. При получении события сервис десериализует данные, проверяет их корректность (если формат события неверен — \texttt{INVALID\_ARGUMENT}) и, в случае необходимости, обогащает информацией из \texttt{ProfileService} (например, подставляет имя пользователя в письмо). После подготовки вызывает \texttt{Brevo API}; при проблемах (недоступность сети, неверные настройки) логирует ошибку и может инициировать повторную отправку (алгоритм повторов настраивается отдельно). Код ответа внешнего сервиса не влияет на \texttt{gRPC}-интерфейс, так как \texttt{Notifications} работает по модели \texttt{Pub/Sub}, а не по \texttt{gRPC}-запросам.

Архитектура: внутри \texttt{NotificationsService} также используется концепция чистой архитектуры: есть слой получателей сообщений (\texttt{Subscriber}) от \texttt{NATS}, слой бизнес-логики (формирование тела письма, выбор шаблона) и слой доставки (\texttt{REST}-клиент к \texttt{Brevo}). Хранилища данных как такового нет (все шаблоны и конфигурации хранятся в конфиге или внутрипамяти). Каждый \texttt{subscriber} запускается как отдельный поток, подписывается на соответствующий \texttt{topic JetStream} и вызывает \texttt{usecase} при получении сообщения. Такая модульная организация упрощает добавление новых типов уведомлений.

Взаимодействие: \texttt{NotificationsService} не предоставляет собственных \\ \texttt{gRPC}-методов клиентам; его задача — слушать события от других сервисов. Например, после регистрации \texttt{AuthService} публикует событие «UserRegistered» (с \texttt{email} и именем), \texttt{Notifications} его получает и вызывает \texttt{Brevo API}. Подобным образом могут обрабатываться события из \texttt{ActivityService} (например, «CommentAdded» для уведомления автора маршрута) или любые другие. Благодаря использованию \texttt{NATS} и \texttt{JetStream} достигается надёжная асинхронная доставка: если сервис упадёт, после перезапуска он продолжит получать неполученные сообщения.

Коды ошибок и устойчивость: \texttt{NotificationsService} возвращает в лог или мониторинг статусы успеха/ошибок \texttt{API Brevo} (например, 502 \texttt{Bad Gateway} при недоступности \texttt{Brevo} трактуется как \texttt{UNAVAILABLE}). В \texttt{gRPC}-слое также можно определить метод \texttt{SendEmail} (например, для ручной отправки), который на вход принимает структуру \texttt{EmailRequest} и возвращает статус. В таком случае возвращаемые коды будут аналогичны: \texttt{INVALID\_ARGUMENT} на неправильный формат адреса или тела письма, \texttt{INTERNAL} на ошибки сервера. Однако основная работа — через асинхронные события и \texttt{REST}, а не через \texttt{gRPC}.

Таким образом, каждый микросервис спроектирован с учётом принципов модульности, слабой связанности и расширяемости. \texttt{AuthService} обеспечивает безопасность и единую авторизацию, \texttt{ProfileService} — персональные данные пользователей, \texttt{ActivityService} — социальные функции, \texttt{ContentService} — хранение маршрутов, \texttt{FileStorageService} — управление файлами, а \\ \texttt{NotificationsService} — оповещения. Между ними устанавливаются чёткие интерфейсы (\texttt{gRPC} и события \texttt{NATS}), что упрощает сопровождение и масштабирование системы. 

\subsection*{3.3 Организация DevOps-инфраструктуры и CI/CD}
\addcontentsline{toc}{subsection}{3.3 Организация DevOps-инфраструктуры и CI/CD}

\subsubsection*{Структура Helm-чартов}
В системе «Путешествия по России» каждый микросервис (\texttt{auth}, \texttt{profile}, \texttt{activity}, \texttt{content}, \texttt{filestorage}, \texttt{notifications}, \texttt{broker}) оформлен отдельным \texttt{Helm}-чартом. Такой подход обеспечивает модульность и независимость сервисов: каждый чарт описывает \texttt{Kubernetes}-ресурсы для одного приложения. Все эти чарты объединены в один родительский чарт \texttt{platform}, в котором с помощью секции \texttt{dependencies} задаются зависимости на каждый микросервис. В блоке \texttt{Chart.yaml} родительского чарта указываются пары \texttt{name}, \texttt{version} и \texttt{repository}, причём в качестве репозитория используется адрес \texttt{OCI}-реестра (например, \texttt{GHCR}). 

При локальной отладке каждый микросервис может запускаться со своим собственным файлом \texttt{values.yaml}, содержащим настройки окружения для разработки. Для деплоя в \texttt{production} используется централизованный набор конфигураций: общий \texttt{values.yaml} и разделённый на обычные и секретные параметры \texttt{values.secret.yaml}. В этих файлах определяются порты, \texttt{URL} сервисов, переменные окружения, параметры подключения к БД и т. д., а чувствительные данные (пароли, токены) выносятся в \texttt{values.secret.yaml} для безопасности. Кроме того, в чартах сервисов, использующих \texttt{PostgreSQL}, настраивается \texttt{Kubernetes Job} с аннотацией \texttt{helm.sh/hook: pre-install,pre-upgrade} для применения миграций схемы базы данных перед установкой или обновлением приложения. Такой \texttt{job} загружает контейнер с миграциями и выполняет \texttt{SQL}-скрипты, гарантируя, что схема БД актуализируется до запуска основного пода.

\subsubsection*{CI/CD (GitHub Actions)}
В каждом репозитории микросервиса организован конвейер \texttt{CI/CD} на базе \texttt{GitHub Actions} с несколькими \texttt{workflow}-файлами. Обычно используются три типа \texttt{workflow}: \texttt{app.yaml} для сборки приложения и создания \texttt{Docker}-образа, \texttt{publish-*-chart.yaml} для упаковки и публикации \texttt{Helm}-чарта, а при наличии \texttt{PostgreSQL} — \texttt{migrations.yaml} для сборки контейнера с миграциями. Все эти действия выполняются в среде \texttt{GitHub Actions} с использованием секретов (например, \texttt{GHCR\_TOKEN}, \texttt{GHCR\_USERNAME}, \texttt{GOPRIVATE\_PAT}) для аутентификации в \texttt{GitHub Container Registry} и доступа к приватным модулям.

Сборка приложения ведётся с помощью многоступенчатого \texttt{Dockerfile}. На этапе \texttt{build} используется образ \texttt{golang:1.24}, в котором скачиваются зависимости (через \texttt{go mod}) и компилируется исполняемый файл. Затем на финальной стадии берётся минимальный образ \texttt{alpine:3.19}, в который копируется только готовый бинарник. В результате итоговый образ получается очень компактным и безопасным: в нём отсутствуют инструменты сборки и прочие ненужные слои. Такой подход значительно уменьшает размер контейнера и поверхность потенциальных уязвимостей.

Настройки триггеров \texttt{workflow} соответствуют следующей логике:
\begin{itemize}
    \item Push в ветку \texttt{main} → выполняется сборка и публикация \texttt{Docker}-образа приложения.
    \item Push тега вида \texttt{chart-*} → запускается упаковка и публикация \texttt{Helm}-чарта в \texttt{GHCR}.
    \item Изменения в папке \texttt{migrations} → инициируется сборка и публикация контейнера миграций.
\end{itemize}
Все собранные \texttt{Docker}-образы и чарты публикуются в \texttt{GitHub Container Registry (GHCR)}, где хранятся как пакеты \texttt{OCI}. Использование \texttt{GHCR} позволяет легко управлять версиями и правами доступа. Каждый релиз получает семантический тег (например, \texttt{v0.1.12}), что обеспечивает трассируемость версий. При необходимости образы и чарты могут быть удалены вручную, иначе \texttt{GHCR} сохраняет их бессрочно, что гарантирует повторяемость окружения.

\subsubsection*{Автоматический деплой (Helm)}
Для автоматического деплоя в репозитории \texttt{vkr-platform} настроен отдельный \texttt{workflow GitHub Actions}. При пуше в ветку \texttt{main} этот \texttt{workflow} выполняет команду \texttt{helm upgrade --install platform}, используя заранее подготовленный \texttt{kubeconfig} (он хранится в \texttt{GitHub Secrets}). Поскольку родительский чарт \texttt{platform} содержит все сервисы в секции \texttt{dependencies}, единственный вызов \texttt{helm} разворачивает все микросервисы сразу. При вызове \texttt{Helm} передаются файлы \texttt{values.yaml} и \texttt{values.secret.yaml} из общего хранилища, в которых заданы порты, \texttt{URL}, переменные окружения, параметры подключения к базе данных и другие настройки. Такой централизованный подход упрощает управление конфигурацией: однократная правка значений в \texttt{values.yaml} отражается на всех сервисах.

Перед запуском каждого сервиса из чарта также выполняются миграции схемы (см. раздел 3.4.1). Например, для сервиса \texttt{auth} определяется \texttt{Kubernetes Job auth-migrations} с аннотацией \texttt{Helm hook}, который применяет \texttt{SQL}-миграции до старта контейнера приложения. Таким образом, структура базы данных гарантированно соответствует версии сервиса. В целом этот \texttt{pipeline} позволяет оперативно и согласованно обновлять всю платформу одной операцией \texttt{Helm} – что повышает надёжность и упрощает откат при необходимости.

\subsubsection*{Логирование}
Во всех микросервисах реализовано структурированное логирование на базе библиотеки \texttt{zap} от Uber. \texttt{Zap} изначально проектировался как очень высокопроизводительный логгер: он обеспечивает «blazing fast» скорость записи и избегает лишних аллокаций при сериализации полей. Например, \texttt{API SugaredLogger} из \texttt{zap} в 4–10 раз быстрее многих аналогичных библиотек. В нашем случае \texttt{zap} обёрнут во внутренний интерфейс логгера приложения. Такая обёртка позволяет при необходимости менять реализацию логирования или дополнять её (например, добавлять новые уровни или форматы) без изменения бизнес-логики.

Логи сервисов пишутся одновременно и в консоль (\texttt{stdout}), и в файл (напр., во внутренний том контейнера). Вывод в \texttt{stdout} соответствует рекомендациям \texttt{Kubernetes}: системный агент \texttt{kubelet} читает эти сообщения и агрегирует их, а разработчики могут просматривать логи через \texttt{kubectl logs}. Запись в файл (например, в монтируемый \texttt{PersistentVolume}) позволяет сохранять полную историю логов и при необходимости передавать её в сторонние системы. Выбранная архитектура лога легко расширяется: в будущем можно подключить отправку логов в \texttt{ELK/Loki}, \texttt{S3} или другие решения, не меняя код микросервисов.

\subsubsection*{Серверное окружение}
Для развертывания микросервисов проекта «Путешествия по России» была использована арендованная виртуальная машина. Параметры виртуального сервера составляют 4 виртуальных ядра процессора (3,3 ГГц), 8 ГБ оперативной памяти и 80 ГБ \texttt{NVMe SSD}-диска. Для доступа к кластеру был выделен статический \texttt{IP}-адрес. Виртуальная машина выступает хост-нодой локального \texttt{Kubernetes}-кластера, в котором развернуты все микросервисы. При запуске всех компонентов в режиме ожидания (без нагрузки) потребление оперативной памяти составляет около 1,5 ГБ.

\subsection*{3.4 Тестирование микросервисной системы}
\addcontentsline{toc}{subsection}{3.4 Тестирование микросервисной системы}

\subsubsection*{Юнит-тестирование}
В \texttt{Go} для написания юнит-тестов используется стандартный пакет \texttt{testing}. Командой \texttt{go test ./...} можно автоматически обнаруживать и выполнять все тесты в проекте.

Дополнительно применяются расширения из библиотеки \texttt{Testify}: пакеты \texttt{assert} и \texttt{require} позволяют делать проверки более выразительными и удобными. Например, \texttt{assert.Equal(t, ожидаемое, фактическое)} упрощает формирование читаемых сообщений об ошибках.

В юнит-тестах проверяются изолированные логические функции микросервисов, не зависящие от внешних компонентов. Сюда относятся задачи валидации данных, генерации и проверки токенов, базовая бизнес-логика «чистых» сервисов и пр. Такие тесты пишутся без обращения к базе данных или сторонним сервисам.

Основная выгода юнит-тестирования – быстрая отладка логики без поднятия всей системы. Это помогает обнаруживать и устранять ошибки на ранних этапах разработки, когда локализовать проблему проще и дешевле. Юнит-тесты гарантируют надёжность каждого компонента как отдельного блока, что повышает устойчивость всей микросервисной архитектуры.

\subsubsection*{Интеграционное тестирование}
Интеграционные тесты проверяют совместную работу сервисов в условиях, близких к реальным. Они направлены на верификацию взаимодействия компонентов и потоков данных между ними, чтобы убедиться, что система функционирует как единое целое. В контексте микросервисов это означает отправку реальных запросов между сервисами через \texttt{API-шлюз (Envoy)} и проверку обработки сообщений через шину (\texttt{NATS JetStream}).
\begin{itemize}
    \item Для тестирования взаимодействия используется \texttt{Postman Collection}, включающая все \texttt{gRPC}- и \texttt{REST}-эндпоинты микросервисов (например, запросы к сервисам \texttt{Auth}, \texttt{Profile}, \texttt{Content}, \texttt{Notifications}). Это позволяет задать последовательность сценариев и проследить, как ответы одного сервиса поступают в следующий.
    \item Запуск коллекции автоматизирован через \texttt{Postman CLI (Newman)} или встроенный \texttt{Runner}. \texttt{Newman} – это инструмент командной строки для выполнения \texttt{Postman} коллекций, который легко интегрируется в \texttt{CI/CD}-пайплайн. К примеру, в \texttt{Kubernetes} можно запустить \texttt{Postman}-контейнер с \texttt{Newman} внутри кластера, чтобы тестировать внутренние сервисы без их внешней экспозиции.
    \item Само тестовое окружение развертывается с помощью \texttt{Helm}-чарта (например, в \texttt{dev}-кластере). Команда \texttt{helm test} позволяет запускать произвольные \texttt{Kubernetes}-ресурсы, включая контейнеры с \texttt{Newman} и тестовыми скриптами. Например, можно использовать официальный образ \texttt{postman/newman} и передавать в него \texttt{JSON}-файлы коллекции и окружения.
    \item Такой подход гарантирует, что система протестирована в условиях, максимально приближенных к продакшену. Проверяется не только логика отдельных \texttt{API}, но и сетевое взаимодействие через \texttt{Envoy}, а также асинхронный обмен сообщениями через \texttt{NATS}. Это позволяет убедиться в корректной работе всего цикла запросов и ответов между сервисами.
\end{itemize}

\subsection*{Выводы по главе}
\addcontentsline{toc}{subsection}{Выводы по главе}
Таким образом, в третьей главе продемонстрирована целостная реализация серверной части приложения «Путешествия по России» — от выбора и обоснования единого технологического стека (\texttt{Go 1.24}, \texttt{gRPC}, \texttt{PostgreSQL}, \texttt{Redis}, \texttt{NATS JetStream}, \texttt{MinIO}) до детального описания микросервисов и \texttt{DevOps} потока, подтверждённого комплексным тестированием. Все сервисы построены на принципах чистой архитектуры, чётко разделяют доменные области (\texttt{Auth}, \texttt{Profile}, \texttt{Content}, \texttt{Activity}, \texttt{FileStorage}, \texttt{Notifications}) и общаются строго типизированными \texttt{gRPC} контрактами, а асинхронные задачи надёжно обрабатываются через \texttt{JetStream} с гарантией хотя бы однократной доставки. Контейнеризация и единая система \texttt{Helm} чартов обеспечивают воспроизводимое развёртывание всей платформы в локальном \texttt{Kubernetes} кластере на выделенной виртуальной машине (4 \texttt{vCPU} 3,3 ГГц, 8 ГБ \texttt{RAM}, 80 ГБ \texttt{NVMe}), где при штатной работе потребление памяти не превышает 1,5 ГБ. Автоматизированные \texttt{CI/CD} конвейеры \texttt{GitHub Actions} формируют минимальные \texttt{Docker} образы, публикуют их вместе с чартами в \texttt{GHCR} и запускают \texttt{Helm upgrade}, гарантируя непрерывную доставку и миграцию схем БД без простоев; структурированное логирование на базе \texttt{zap} и ротация \texttt{lumberjack} предусматривают последующее подключение централизованной системы сбора логов. Юнит тесты (\texttt{testing + testify}) подтверждают корректность ключевой бизнес логики в изоляции, а интеграционные сценарии \texttt{Postman/Newman}, исполняемые в \texttt{dev} кластере через \texttt{helm test}, удостоверяют согласованность микросервисного взаимодействия и работу критических путей через \texttt{Envoy} и \texttt{JetStream} в среде, максимально приближённой к \texttt{production}. Совокупность изложенных решений демонстрирует, что реализованная архитектура не только удовлетворяет функциональным требованиям, но и обладает заложенными во второй главе нефункциональными характеристиками — масштабируемостью, отказоустойчивостью, безопасностью и готовностью к дальнейшему расширению.
